	/** When a leading note is selected, this gets filled with times of how far every other selected thing was from the new leading note */
	let differencesToLeading = { notes: [], events: [] };
	function setLeading(stamp: ChartStamp) {
		ChartState.selectionBox.leadingStamp = stamp;

		differencesToLeading.notes = ChartState.song.chart.notes.map((note) => {
			return ChartState.conductor.timeToStep(note.time)
				- ChartState.conductor.timeToStep(ChartState.selectionBox.leadingStamp.time);
		});

		differencesToLeading.events = ChartState.song.chart.events.map((ev) => {
			return ChartState.conductor.timeToStep(ev.time)
				- ChartState.conductor.timeToStep(ChartState.selectionBox.leadingStamp.time);
		});
	}

	Behaviour for placing and selecting notes
	const leftMousePress = onMousePress("left", () => {
		/** The current hovered time */
		const hoveredTime = ChartState.conductor.stepToTime(ChartState.hoveredStep);

		function noteBehaviour() {
			let hoveredNote = ChartState.notes.find((note) => note.isHovering());

			there's already a note in that place
			if (hoveredNote) {
				if (!isKeyDown("control")) ChartState.notes.forEach((note) => note.selected = false);
				if (!hoveredNote.selected) hoveredNote.selected = true;
				if (hoveredNote.data.length) {
				}
				else {
				}
			}
			there's no note in that place
			else {
				hoveredNote = ChartState.placeNote(hoveredTime);
				EditorUtils.noteSound(hoveredNote.data, "Add");
				hoveredNote.selected = true;

				setLeading(hoveredNote);

		stretchingNoteEV?.cancel();
		stretchingNoteEV = onMouseMove(() => {
			let oldLength = hoveredNote.length;
			const noteLength = Math.floor(
				(ChartState.hoveredStep)
					- ChartState.conductor.timeToStep(hoveredNote.time),
			);
			hoveredNote.length = noteLength > 0 ? noteLength : undefined;
			let newLength = hoveredNote.length;
			if (oldLength != newLength) {
				const detune = newLength % 2 == 0 ? 0 : 100;
				Sound.playSound("noteStretch", { detune: detune });
			}
		});

		const releaseEV = onMouseRelease(() => {
			if (hoveredNote.length) Sound.playSound("noteSnap", { detune: rand(-25, 25) });
			releaseEV.cancel();
			stretchingNoteEV?.cancel();
			stretchingNoteEV = null;
		});
			}

			ChartState.stepForDetune = ChartState.conductor.timeToStep(hoveredNote.time);
		}

		function eventBehaviour() {
			let hoveredEvent = EditorUtils.stamps.getHovered("event");

			there's already an event in that place
			if (hoveredEvent) {
				if (!ChartState.selectedStamps.includes(hoveredEvent)) {
					if (!isKeyDown("control")) ChartState.resetSelectedStamps();
					ChartState.selectedStamps.push(hoveredEvent);
				}
			}
			else {
				ChartState.resetSelectedStamps();
				hoveredEvent = ChartState.placeEvent(hoveredTime, ChartState.currentEvent);
				Sound.playSound("noteAdd", { detune: rand(-50, 50) });
				Sound.playSound("eventCog", { detune: rand(-50, 50) });
			}

			setLeading(hoveredEvent);
			ChartState.stepForDetune = ChartState.conductor.timeToStep(hoveredEvent.time);
		}

		if it's not on the grid at all simply reset selected notes
		if (!ChartState.isCursorInGrid) {
			if it's not hovering anything clickable, deselect
			if (
				!get("hover", { recursive: true }).some((obj) => obj.isHovering())
				&& !get("editorTab").some((obj) => obj.isHovering)
			) {
				EditorCommands.DeselectAll();
			}
		}
		else {
			if (ChartState.isInNoteGrid) noteBehaviour();
			else if (ChartState.isInEventGrid) eventBehaviour();
		}
	});

	Resets the detune for moving notes
	onMouseRelease("left", () => {
		ChartState.selectionBox.leadingStamp = undefined;
	});

	Removing notes
	const rightMousePress = onMousePress("right", () => {
		if (!ChartState.isCursorInGrid) return;

		function noteBehaviour() {
			const note = EditorUtils.stamps.getHovered("note");
			if (!note) return;

			if (EditorUtils.stamps.trailAtStep(ChartState.hoveredStep)) {
				if you click the trail instead of the note it will only remove the trail rather than the note
				note.length = undefined;
				Sound.playSound("noteSnap", { detune: -50 });
			}
			else {
				ChartState.deleteNote(note);
				EditorUtils.noteSound(note, "Remove");
			}
		}

		function eventBehaviour() {
			const hoveredEvent = EditorUtils.stamps.getHovered("event");

			if (!hoveredEvent) return;
			ChartState.deleteEvent(hoveredEvent);
			Sound.playSound("noteRemove");
			Sound.playSound("eventCog", { detune: rand(-50, 50) });
		}

		if (ChartState.isInNoteGrid) noteBehaviour();
		else if (ChartState.isInEventGrid) eventBehaviour();
	});

	Behaviour for moving notes
	const rightMouseDown = onMouseDown("left", () => {
		if (stretchingNoteEV) return;
		if (!ChartState.selectionBox.leadingStamp) return;

		let oldStepOfLeading = ChartState.conductor.timeToStep(ChartState.selectionBox.leadingStamp.time);
		oldStepOfLeading = Math.round(oldStepOfLeading);

		ChartState.selectedStamps.forEach((selectedStamp, index) => {
			is the leading stamp
			if (selectedStamp == ChartState.selectionBox.leadingStamp) {
				let newStep = ChartState.hoveredStep;
				newStep = clamp(newStep, 0, ChartState.conductor.totalSteps - 1);

				selectedStamp.time = ChartState.conductor.stepToTime(newStep);
				ChartState.selectionBox.leadingStamp = selectedStamp;
			}
			else {
				const isNote = EditorUtils.stamps.isNote(selectedStamp);

				const leadingStampStep = ChartState.conductor.timeToStep(ChartState.selectionBox.leadingStamp.time);

				if (isNote) {
					const indexInNotes = ChartState.song.chart.notes.indexOf(selectedStamp);

					this is some big brain code i swear
					const stepDiff = differencesToLeading.notes[indexInNotes];
					let newStep = leadingStampStep + stepDiff;
					newStep = clamp(newStep, 0, ChartState.conductor.totalSteps - 1);
					selectedStamp.time = ChartState.conductor.stepToTime(newStep);
				}
				else {
					const indexInEvents = ChartState.song.chart.events.indexOf(selectedStamp);

					this is some big brain code i swear
					const stepDiff = differencesToLeading.events[indexInEvents];
					let newStep = leadingStampStep + stepDiff;
					newStep = clamp(newStep, 0, ChartState.conductor.totalSteps - 1);
					selectedStamp.time = ChartState.conductor.stepToTime(newStep);
				}
			}
		});

		let newStepOfLeading = ChartState.conductor.timeToStep(ChartState.selectionBox.leadingStamp.time);
		newStepOfLeading = Math.round(newStepOfLeading);

		if (newStepOfLeading != oldStepOfLeading) {
			// thinking WAY too hard for a simple sound effect lol!
			const diff = newStepOfLeading - ChartState.stepForDetune;
			let baseDetune = 0;

			if (EditorUtils.stamps.isNote(ChartState.selectionBox.leadingStamp)) {
				baseDetune = Math.abs(EditorUtils.moveToDetune(ChartState.selectionBox.leadingStamp.move)) * 0.5;
			}
			else {
				baseDetune = Object.keys(ChartEvent.eventSchema).indexOf(ChartState.selectionBox.leadingStamp.id)
					* 10;
			}

			Sound.playSound("noteMove", { detune: baseDetune * diff });
		}
	});

	Copies the color of a note
	onMousePress("middle", () => {
		if (ChartState.isInNoteGrid) {
			const currentHoveredNote = EditorUtils.stamps.getHovered("note");
			if (currentHoveredNote && ChartState.currentMove != currentHoveredNote.move) {
				ChartState.changeMove(currentHoveredNote.move);
			}
		}
		else {
			const currentHoveredEvent = EditorUtils.stamps.getHovered("event");
			if (currentHoveredEvent && ChartState.currentEvent != currentHoveredEvent.id) {
				ChartState.currentEvent = currentHoveredEvent.id as keyof typeof ChartEvent.eventSchema;
			}
		}
	});

